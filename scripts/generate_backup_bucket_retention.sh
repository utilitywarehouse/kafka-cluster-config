#!/usr/bin/env bash

# --- START VALIDATION ---
# Ensure exactly one argument is provided and it's either "dev" or "prod".
if [[ "$#" -ne 1 || ("$1" != "dev" && "$1" != "prod") ]]; then
  echo "Usage: $0 <dev|prod>" >&2
  echo "Error: Please provide a single environment argument: 'dev' or 'prod'." >&2
  exit 1
fi
# --- END VALIDATION ---

env=$1

root_cluster="../${env}-aws/kafka-shared-msk"
S3_PREFIX="msk-backup-parquet"
OUTPUT_DIR="${root_cluster}/msk-backup-bucket-retention"
OUTPUT_FILE="${OUTPUT_DIR}/retention.tf"

TMP=$(mktemp)

# Extract topic=days from name attribute, skip retention.ms <= 0
find "${root_cluster}" -name "*.tf" -print0 | xargs -0 awk '
  BEGIN {
    total_resources=0
    infinite_topics=0
    no_retention_topics=0
    empty_name_topics=0
  }
  /resource "kafka_topic"/ {
    in_resource=1
    topic=""
    retention_ms=""
    resource_name=$3
    gsub(/"/,"",resource_name)
  }
  in_resource && /name[ ]*=/ {
    topic=$NF
    gsub(/"/,"",topic)
    gsub(/[ \t]/,"",topic)
  }
  in_resource && /"retention.ms"/ {
    retention_ms=$3
    gsub(/[^0-9-]/,"",retention_ms)
  }
  in_resource && /^}/ {
    # Process at end of resource block
    total_resources++

    if(topic == "") {
      empty_name_topics++
      print "WARNING: Empty topic name for resource: " resource_name > "/dev/stderr"
    }

    if(retention_ms == "") {
      no_retention_topics++
    } else if(retention_ms+0 <= 0) {
      infinite_topics++
    } else {
      # Valid retention with positive value
      d=int(retention_ms/86400000) + 1
      if(topic!="") {
        print topic "=" d
      }
    }

    in_resource=0
    topic=""
    retention_ms=""
  }
  END {
    print "\n=== Statistics ===" > "/dev/stderr"
    print "Total kafka_topic resources found: " total_resources > "/dev/stderr"
    print "Topics with infinite retention (retention.ms <= 0): " infinite_topics > "/dev/stderr"
    print "Topics without retention.ms (compacted topics): " no_retention_topics > "/dev/stderr"
    print "Topics with empty name: " empty_name_topics > "/dev/stderr"
    print "Topics with associated bucket rules: " (total_resources - infinite_topics - no_retention_topics) > "/dev/stderr"
  }
' > "$TMP"

# Create output directory if it doesn't exist
mkdir -p "$OUTPUT_DIR"

# Print lifecycle rules - one rule per topic
awk -F= -v s3_prefix="$S3_PREFIX" -v env="$env" '
{
  topic=$1
  days=$2
  topics[topic]=days
}
END {
  # Print header
  print "#################################"
  print "# DO NOT update this file manually, it is autogenerated"
  print "#################################"
  print ""
  print "resource \"aws_s3_bucket_lifecycle_configuration\" \"msk_topics_retention\" {"
  print "  bucket = \"uw-" env "-pubsub-msk-backup\""
  print ""

  # Sort topics alphabetically
  n=0
  for(t in topics) topics_arr[++n]=t
  for(i=1;i<=n;i++){
    for(j=i+1;j<=n;j++){
      if(topics_arr[i]>topics_arr[j]){tmp=topics_arr[i];topics_arr[i]=topics_arr[j];topics_arr[j]=tmp}
    }
  }

  # Generate one rule per topic
  for(i=1;i<=n;i++){
    topic=topics_arr[i]
    d=topics[topic]
    s3_path=topic; gsub("_",".",s3_path)
    printf "  rule {\n"
    printf "    id     = \"%s\"\n", topic
    printf "    status = \"Enabled\"\n"
    printf "    expiration { days = %d }\n", d
    printf "    filter { prefix = \"%s/%s/\" }\n", s3_prefix, s3_path
    printf "  }\n\n"
  }

  # Print closing brace
  print "}"
}' "$TMP" > "$OUTPUT_FILE"

rm "$TMP"

echo "Generated: $OUTPUT_FILE"
