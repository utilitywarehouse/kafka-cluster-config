#!/usr/bin/env bash

root_cluster=$1
S3_PREFIX="msk-backup-parquet"
OUTPUT_DIR="${root_cluster}/msk-backup-bucket-retention"
OUTPUT_FILE="${OUTPUT_DIR}/retention.tf"

TMP=$(mktemp)

# Extract topic=days from name attribute, skip retention.ms <= 0
find ${root_cluster} -name "*.tf" | xargs awk '
  /resource "kafka_topic"/ { 
    in_resource=1
    topic=""
    retention_ms=""
    resource_name=$3
    gsub(/"/,"",resource_name)
  }
  in_resource && /name[ ]*=/ { 
    topic=$NF
    gsub(/"/,"",topic)
    gsub(/[ \t]/,"",topic)
  }
  in_resource && /"retention.ms"/ {
    retention_ms=$3
    gsub(/[^0-9-]/,"",retention_ms)
  }
  in_resource && /^}/ {
    # Process at end of resource block
    if(topic== "" ) {
      print "WARNING: Empty topic name for resource: " resource_name > "/dev/stderr"
    }
    if(retention_ms == "") {
      print "WARNING: Empty retention.ms for resource: " resource_name > "/dev/stderr"
    }
    if(retention_ms != "" && topic != "") {
      # Skip if retention.ms is <= 0 (infinite or invalid retention)
      if(retention_ms+0 > 0) {
        # add 1 day to topic retention for safety
        d=int(retention_ms/86400000) + 1
        print topic "=" d
      } else {
        print "INFO: Skipping infinite retention topic for resource " resource_name " (retention.ms=" retention_ms ")" > "/dev/stderr"
      }
    }
    in_resource=0
    topic=""
    retention_ms=""
  }
' > "$TMP"

# Create output directory if it doesn't exist
mkdir -p "$OUTPUT_DIR"

# Print lifecycle rules - one rule per topic
awk -F= -v s3_prefix="$S3_PREFIX" '
{
  topic=$1
  days=$2
  topics[topic]=days
}
END {
  # Print header
  print "#################################"
  print "# DO NOT update this file manually, it is autogenerated"
  print "#################################"
  print ""
  print "resource \"aws_s3_bucket_lifecycle_configuration\" \"msk_topics_retention\" {"
  print "  bucket = \"uw-dev-pubsub-msk-backup\""
  print ""

  # Sort topics alphabetically
  n=0
  for(t in topics) topics_arr[++n]=t
  for(i=1;i<=n;i++){
    for(j=i+1;j<=n;j++){
      if(topics_arr[i]>topics_arr[j]){tmp=topics_arr[i];topics_arr[i]=topics_arr[j];topics_arr[j]=tmp}
    }
  }

  # Generate one rule per topic
  for(i=1;i<=n;i++){
    topic=topics_arr[i]
    d=topics[topic]
    s3_path=topic; gsub("_",".",s3_path)
    printf "  rule {\n"
    printf "    id     = \"%s\"\n", topic
    printf "    status = \"Enabled\"\n"
    printf "    expiration { days = %d }\n", d
    printf "    filter { prefix = \"%s/%s/\" }\n", s3_prefix, s3_path
    printf "  }\n\n"
  }

  # Print closing brace
  print "}"
}' "$TMP" > "$OUTPUT_FILE"

#rm "$TMP"
echo "TMP file is at $TMP"
echo "Generated: $OUTPUT_FILE"
